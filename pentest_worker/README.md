# Pentest API with Celery Worker

REST API для выполнения пентест-операций с асинхронной обработкой через Celery.

## Архитектура

```
┌─────────────┐      ┌──────────────┐      ┌─────────────┐
│   Client    │─────>│ FastAPI API  │─────>│    Redis    │
│  (Django)   │      │  (port 8001) │      │   (broker)  │
└─────────────┘      └──────────────┘      └─────────────┘
       │                     │                      │
       │                     │                      ▼
       │                     │              ┌─────────────┐
       │                     └─────────────>│   Celery    │
       │                                    │   Worker    │
       └───────────── result ◄──────────────┤             │
                                            └─────────────┘
```

## Запуск

```bash
# Собрать и запустить все сервисы
docker compose -f compose.dev.yml up --build

# Или только pentest сервисы
docker compose -f compose.dev.yml up redis pentest-api pentest-worker
```

## Эндпоинты

### Health Check
```bash
curl http://localhost:8001/health
```

### Ping
```bash
# Создать задачу
curl -X POST http://localhost:8001/ping \
  -H "Content-Type: application/json" \
  -d '{"target": "google.com", "timeout": 4}'

# Ответ: {"task_id": "abc-123", "status": "pending", "message": "..."}

# Получить результат
curl http://localhost:8001/task/abc-123
```

### Port Scan
```bash
curl -X POST http://localhost:8001/port-scan \
  -H "Content-Type: application/json" \
  -d '{"target": "scanme.nmap.org", "ports": "80,443,22"}'
```

### DNS Lookup
```bash
curl -X POST http://localhost:8001/dns-lookup \
  -H "Content-Type: application/json" \
  -d '{"domain": "google.com"}'
```

### HTTP Headers
```bash
curl -X POST http://localhost:8001/http-headers \
  -H "Content-Type: application/json" \
  -d '{"url": "https://example.com"}'
```

## Swagger UI

Документация доступна по адресу: http://localhost:8001/docs

## Добавление новых операций

1. Создайте задачу в `tasks.py`:
```python
@celery_app.task(bind=True, base=CallbackTask, name="tasks.my_operation")
def my_operation(self, target: str) -> dict:
    # Ваш код
    return {"success": True, "result": "..."}
```

2. Добавьте схему в `schemas.py`:
```python
class MyOperationRequest(BaseModel):
    target: str
```

3. Добавьте эндпоинт в `main.py`:
```python
@app.post("/my-operation", response_model=TaskResponse)
async def create_my_operation_task(request: MyOperationRequest):
    task = my_operation.apply_async(args=[request.target])
    return TaskResponse(task_id=task.id, status="pending", message="...")
```

## Мониторинг Celery

```bash
# Список активных воркеров
docker compose -f compose.dev.yml exec pentest-worker celery -A celery_app inspect active

# Статистика воркеров
docker compose -f compose.dev.yml exec pentest-worker celery -A celery_app inspect stats

# Список зарегистрированных задач
docker compose -f compose.dev.yml exec pentest-worker celery -A celery_app inspect registered
```

## Настройка

Переменные окружения в `compose.dev.yml`:
- `REDIS_URL`: URL для подключения к Redis
- `CELERY_BROKER_URL`: URL брокера Celery
- `CELERY_RESULT_BACKEND`: URL для хранения результатов

## Безопасность

⚠️ **Важно для production**:
1. Ограничьте CORS в `main.py` на конкретные домены
2. Добавьте аутентификацию (JWT токены)
3. Ограничьте ресурсы контейнера (CPU, memory)
4. Используйте rate limiting
5. Валидируйте все входные данные
