from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from celery.result import AsyncResult
import redis

from config import settings
from celery_app import celery_app
from schemas import (
    PingRequest,
    PortScanRequest,
    DNSLookupRequest,
    HTTPHeadersRequest,
    TaskResponse,
    TaskResultResponse,
    HealthResponse,
)
from tasks import ping_host, port_scan, dns_lookup, http_headers


app = FastAPI(
    title=settings.api_title,
    version=settings.api_version,
    description="Pentest operations API with async task queue",
)

# CORS middleware для доступа из Django
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # В продакшене указать конкретные домены
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


@app.get("/", tags=["Root"])
async def root():
    """API root endpoint"""
    return {
        "message": "Pentest API",
        "version": settings.api_version,
        "endpoints": {
            "health": "/health",
            "ping": "/ping",
            "port_scan": "/port-scan",
            "dns_lookup": "/dns-lookup",
            "http_headers": "/http-headers",
            "task_result": "/task/{task_id}",
        }
    }


@app.get("/health", response_model=HealthResponse, tags=["Health"])
async def health_check():
    """Check API and dependencies health"""
    try:
        # Проверяем Redis
        r = redis.from_url(settings.redis_url)
        r.ping()
        redis_connected = True
    except Exception:
        redis_connected = False
    
    # Проверяем Celery workers
    inspect = celery_app.control.inspect()
    active_workers = inspect.active()
    worker_count = len(active_workers) if active_workers else 0
    
    status = "healthy" if redis_connected and worker_count > 0 else "degraded"
    
    return HealthResponse(
        status=status,
        redis_connected=redis_connected,
        celery_workers=worker_count,
    )


@app.post("/ping", response_model=TaskResponse, tags=["Pentest"])
async def create_ping_task(request: PingRequest):
    """
    Start a ping task for the specified target.
    Returns task_id for checking status later.
    """
    task = ping_host.apply_async(args=[request.target, request.timeout])
    
    return TaskResponse(
        task_id=task.id,
        status="pending",
        message=f"Ping task created for {request.target}",
    )


@app.post("/port-scan", response_model=TaskResponse, tags=["Pentest"])
async def create_port_scan_task(request: PortScanRequest):
    """
    Start a port scan task for the specified target.
    Returns task_id for checking status later.
    """
    task = port_scan.apply_async(args=[request.target, request.ports])
    
    return TaskResponse(
        task_id=task.id,
        status="pending",
        message=f"Port scan task created for {request.target}",
    )


@app.post("/dns-lookup", response_model=TaskResponse, tags=["Pentest"])
async def create_dns_lookup_task(request: DNSLookupRequest):
    """
    Start a DNS lookup task for the specified domain.
    Returns task_id for checking status later.
    """
    task = dns_lookup.apply_async(args=[request.domain])
    
    return TaskResponse(
        task_id=task.id,
        status="pending",
        message=f"DNS lookup task created for {request.domain}",
    )


@app.post("/http-headers", response_model=TaskResponse, tags=["Pentest"])
async def create_http_headers_task(request: HTTPHeadersRequest):
    """
    Start an HTTP headers fetch task for the specified URL.
    Returns task_id for checking status later.
    """
    task = http_headers.apply_async(args=[request.url])
    
    return TaskResponse(
        task_id=task.id,
        status="pending",
        message=f"HTTP headers task created for {request.url}",
    )


@app.get("/task/{task_id}", response_model=TaskResultResponse, tags=["Tasks"])
async def get_task_result(task_id: str):
    """
    Get the result of a task by its ID.
    
    Statuses:
    - PENDING: Task is waiting in queue
    - PROGRESS: Task is being executed
    - SUCCESS: Task completed successfully
    - FAILURE: Task failed with error
    """
    task_result = AsyncResult(task_id, app=celery_app)
    
    if not task_result:
        raise HTTPException(status_code=404, detail="Task not found")
    
    response = TaskResultResponse(
        task_id=task_id,
        status=task_result.state,
    )
    
    if task_result.state == "PENDING":
        response.result = None
        response.error = None
    elif task_result.state == "PROGRESS":
        response.meta = task_result.info
    elif task_result.state == "SUCCESS":
        response.result = task_result.result
    elif task_result.state == "FAILURE":
        response.error = str(task_result.info)
    
    return response


@app.delete("/task/{task_id}", tags=["Tasks"])
async def revoke_task(task_id: str):
    """Cancel a running or pending task"""
    celery_app.control.revoke(task_id, terminate=True)
    
    return {
        "task_id": task_id,
        "message": "Task revocation requested",
    }


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8001)
