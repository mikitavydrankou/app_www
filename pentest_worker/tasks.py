import subprocess
import time
from typing import Optional

from celery import Task
from celery_app import celery_app
from ping3 import ping


class CallbackTask(Task):
    """Базовый класс для задач с обработкой ошибок"""
    
    def on_failure(self, exc, task_id, args, kwargs, einfo):
        print(f"Task {task_id} failed: {exc}")
        super().on_failure(exc, task_id, args, kwargs, einfo)


@celery_app.task(bind=True, base=CallbackTask, name="tasks.ping_host")
def ping_host(self, target: str, timeout: int = 4) -> dict:
    """
    Пингует указанный хост и возвращает результат.
    
    Args:
        target: Домен или IP-адрес
        timeout: Таймаут в секундах
    
    Returns:
        dict с полями: success, latency_ms, error, target
    """
    try:
        self.update_state(state="PROGRESS", meta={"status": f"Pinging {target}..."})
        
        latency_ms = ping(target, timeout=timeout, unit="ms")
        
        if latency_ms is None or latency_ms is False:
            return {
                "success": False,
                "latency_ms": None,
                "error": "No response from host",
                "target": target,
            }
        
        return {
            "success": True,
            "latency_ms": float(latency_ms),
            "error": None,
            "target": target,
        }
    
    except Exception as exc:
        return {
            "success": False,
            "latency_ms": None,
            "error": str(exc),
            "target": target,
        }


@celery_app.task(bind=True, base=CallbackTask, name="tasks.port_scan")
def port_scan(self, target: str, ports: Optional[str] = "80,443,22,21,25") -> dict:
    """
    Сканирует открытые порты на целевом хосте с помощью nmap.
    
    Args:
        target: Домен или IP-адрес
        ports: Порты для сканирования (через запятую)
    
    Returns:
        dict с результатами сканирования
    """
    try:
        self.update_state(state="PROGRESS", meta={"status": f"Scanning {target}..."})
        
        cmd = ["nmap", "-p", ports, "-T4", "--open", target]
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=120,
        )
        
        if result.returncode != 0:
            return {
                "success": False,
                "target": target,
                "error": result.stderr or "Nmap scan failed",
                "output": None,
            }
        
        return {
            "success": True,
            "target": target,
            "error": None,
            "output": result.stdout,
        }
    
    except subprocess.TimeoutExpired:
        return {
            "success": False,
            "target": target,
            "error": "Scan timeout exceeded",
            "output": None,
        }
    except Exception as exc:
        return {
            "success": False,
            "target": target,
            "error": str(exc),
            "output": None,
        }


@celery_app.task(bind=True, base=CallbackTask, name="tasks.dns_lookup")
def dns_lookup(self, domain: str) -> dict:
    """
    Выполняет DNS lookup для домена.
    
    Args:
        domain: Доменное имя
    
    Returns:
        dict с результатами DNS lookup
    """
    try:
        self.update_state(state="PROGRESS", meta={"status": f"Looking up {domain}..."})
        
        cmd = ["nslookup", domain]
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=10,
        )
        
        return {
            "success": result.returncode == 0,
            "domain": domain,
            "output": result.stdout,
            "error": result.stderr if result.returncode != 0 else None,
        }
    
    except Exception as exc:
        return {
            "success": False,
            "domain": domain,
            "output": None,
            "error": str(exc),
        }


@celery_app.task(bind=True, base=CallbackTask, name="tasks.http_headers")
def http_headers(self, url: str) -> dict:
    """
    Получает HTTP заголовки для URL.
    
    Args:
        url: URL для проверки
    
    Returns:
        dict с HTTP заголовками
    """
    try:
        self.update_state(state="PROGRESS", meta={"status": f"Fetching headers from {url}..."})
        
        cmd = ["curl", "-I", "-s", "--max-time", "10", url]
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=15,
        )
        
        if result.returncode != 0:
            return {
                "success": False,
                "url": url,
                "headers": None,
                "error": "Failed to fetch headers",
            }
        
        lines = result.stdout.strip().split("\n")
        headers = {}
        status_line = lines[0] if lines else ""
        
        for line in lines[1:]:
            if ":" in line:
                key, value = line.split(":", 1)
                headers[key.strip()] = value.strip()
        
        return {
            "success": True,
            "url": url,
            "status": status_line,
            "headers": headers,
            "error": None,
        }
    
    except Exception as exc:
        return {
            "success": False,
            "url": url,
            "headers": None,
            "error": str(exc),
        }
